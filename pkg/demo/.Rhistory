thisEinrichtungenL <- thisEinrichtungenL[sapply(thisEinrichtungenL, nrow)!=0]
skwL <- lapply(thisEinrichtungenL, FUN=skalenwerte,
Schichtung=S,
einrichtungen=einrichtungen,
kriterien=GesamtPlus)
QB1L <- lapply(skwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE)
QB2L <- lapply(skwL, function(X, ...) colMeans(X[QB2, ], ...), na.rm=TRUE)
GPL <- lapply(skwL, function(X, ...) colMeans(X[GesamtPlus, ], ...), na.rm=TRUE)
### Skalenwerte der Bereiche in der Population
tmp <- popMeansE(QB1L)
tmp2 <- cbind(tmp, Design=Design, Gewichtung=rownames(tmp))
QB1out <- rbind(QB1out, tmp2)
QB1out
Design <- "SEG.2"
print(Design)
if(Design %in% c("QPR", "HWO")){S <- "Pflegestufe"}
if(!Design %in% c("QPR", "HWO")){ S <- Design}
if(Design %in% c("SEG.2.1", "SEG.2.2", "SEG.2F")) S <- "SEG.2"
thisEinrichtungenL <- lapply(einrichtungenL, FUN=function(X){X[!is.na(X[, S]),]})
thisEinrichtungenL <- thisEinrichtungenL[sapply(thisEinrichtungenL, nrow)!=0]
skwL <- lapply(thisEinrichtungenL, FUN=skalenwerte,
Schichtung=S,
einrichtungen=einrichtungen,
kriterien=GesamtPlus)
QB1L <- lapply(skwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE)
QB2L <- lapply(skwL, function(X, ...) colMeans(X[QB2, ], ...), na.rm=TRUE)
GPL <- lapply(skwL, function(X, ...) colMeans(X[GesamtPlus, ], ...), na.rm=TRUE)
Design <- "WL"
print(Design)
if(Design %in% c("QPR", "HWO")){S <- "Pflegestufe"}
if(!Design %in% c("QPR", "HWO")){ S <- Design}
if(Design %in% c("SEG.2.1", "SEG.2.2", "SEG.2F")) S <- "SEG.2"
thisEinrichtungenL <- lapply(einrichtungenL, FUN=function(X){X[!is.na(X[, S]),]})
thisEinrichtungenL <- thisEinrichtungenL[sapply(thisEinrichtungenL, nrow)!=0]
skwL <- lapply(thisEinrichtungenL, FUN=skalenwerte,
Schichtung=S,
einrichtungen=einrichtungen,
kriterien=GesamtPlus)
QB1L <- lapply(skwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE)
QB2L <- lapply(skwL, function(X, ...) colMeans(X[QB2, ], ...), na.rm=TRUE)
GPL <- lapply(skwL, function(X, ...) colMeans(X[GesamtPlus, ], ...), na.rm=TRUE)
QB1L
tmp <- popMeansE(QB1L)
tmp2 <- cbind(tmp, Design=Design, Gewichtung=rownames(tmp))
tmp2
################################################################################
#
#   Code zur Stichprobenziehung ambulant
#
################################################################################
###################################################
### Funktionen laden und Datenstrukturen anlegen
###################################################
source("../../Oktober2011/functions2.R")
source("sizeAmbulantSEG2F.R")
load("../daten/einrichtungen.rda")
Gesamt <- paste("T", 1:37, sep="")
QB1  <- paste("T", 1:17, sep="")
QB2 <- paste("T", 18:27, sep="")
QB3  <- paste("T", 28:37, sep="")
#einrichtKrit <- paste("T", 29:37, sep="")
# Daten noch einlesen
# Designs : SEG.2, SEG.2F, WL, QPR, HWO
# DesignL <- c("QPR", "HWO", "SEG.2F", "SEG.2", "MDK.1", "MDK.2")
DesignL <- c("SEG.2.1", "SEG.2.2", "WL", "SEG.2F")
GoodnessL <- c("Bias", "STD", "RMSE")
KriterienL <- c("Gesamt", "QB1", "QB2")
GewichtungL <- c("Einfach", "Proportional", "Vergleichbar")
einrichtungen$ID_Auftrag <- as.character(einrichtungen$ID_Auftrag)
### Muss auf jeden Fall wieder raus!!!!
#einrichtungen <- einrichtungen[einrichtungen$ID_Auftrag != "9A535BA875F47F7FC1257966003BB227", ]
einrichtungenL <- split(einrichtungen, f=einrichtungen$ID_Auftrag)
ID_Auftrag <- unique(einrichtungen$ID_Auftrag)
GesamtPlus <- Gesamt
ergArray <- array(NA, dim=c(length(DesignL), length(GoodnessL), length(KriterienL), length(GewichtungL), length(ID_Auftrag)),
dimnames=(list(Design=DesignL,
Goodness=GoodnessL,
Kriterien=KriterienL,
Gewichtung=GewichtungL,
ID_Auftrag=ID_Auftrag)))
boxData <- data.frame(kriterien=NA,
gewichtung=NA,
samplestat=NA,
sample=NA,
design=NA,
einrichtung=NA)
nmissDat <- data.frame(kriterien=NA, missed=NA, design=NA, einrichtung=NA)
QB1out <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
QB2out <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,,
Design=NA, Gewichtung=NA)
GPout <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
for(Design in DesignL){
print(Design)
if(Design %in% c("QPR", "HWO")){S <- "Pflegestufe"}
if(!Design %in% c("QPR", "HWO")){ S <- Design}
if(Design %in% c("SEG.2.1", "SEG.2.2", "SEG.2F")) S <- "SEG.2"
thisEinrichtungenL <- lapply(einrichtungenL, FUN=function(X){X[!is.na(X[, S]),]})
thisEinrichtungenL <- thisEinrichtungenL[sapply(thisEinrichtungenL, nrow)!=0]
skwL <- lapply(thisEinrichtungenL, FUN=skalenwerte,
Schichtung=S,
einrichtungen=einrichtungen,
kriterien=GesamtPlus)
QB1L <- lapply(skwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE)
QB2L <- lapply(skwL, function(X, ...) colMeans(X[QB2, ], ...), na.rm=TRUE)
GPL <- lapply(skwL, function(X, ...) colMeans(X[GesamtPlus, ], ...), na.rm=TRUE)
### Skalenwerte der Bereiche in der Population
tmp <- popMeansE(QB1L)
tmp2 <- cbind(tmp, Design=Design, Gewichtung=rownames(tmp))
QB1out <- rbind(QB1out, tmp2)
tmp <- popMeansE(QB2L)
tmp2 <- cbind(tmp, Design=Design, Gewichtung=rownames(tmp))
QB2out <- rbind(QB2out, tmp2)
tmp <- popMeansE(GPL)
tmp2 <- cbind(tmp, Design=Design, Gewichtung=rownames(tmp))
GPout <- rbind(GPout, tmp2)
#ID <- ID_Auftrag[1]
for(ID in ID_Auftrag){
print(ID)
if(ID %in% setdiff(names(einrichtungenL), names(thisEinrichtungenL))){next}
## Mehrere Stichprobenziehungen
set.seed(123)
if(Design=="WL"){
sL <- samples(einrichtungenL[[ID]], b=100, Schichtung=S,
nh=c(3,2,1))
}
if(Design=="SEG.2.1"){
sL <- samples(einrichtungenL[[ID]], b=100, Schichtung=S,
nh=c(1,1,1,1,1))
}
if(Design=="SEG.2.2"){
sL <- samples(einrichtungenL[[ID]], b=100, Schichtung=S,
nh=c(2,2,2,2,2))
}
if(S=="SEG.2F"){
sL <- samples(einrichtungenL[[ID]], b=100, Schichtung=S,
nh=sampleSizeAmbulantF(einrichtungenL[[ID]]))
}
#######################################
### Skalenwerte (Stichproben)
###################################################
if(S=="Pflegestufe"){
sskwL <- lapply(sL, FUN=skalenwerte, Schichtung=S,
einrichtungen=einrichtungen, kriterien=GesamtPlus)
}
if(S!="Pflegestufe"){
sskwL <- lapply(sL, FUN=skalenwerte, Schichtung=S,
einrichtungen=einrichtungen, kriterien=GesamtPlus)
}
sQB1L <- as.matrix(lapply(sskwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE))
sQB2L <- as.matrix(lapply(sskwL, function(X, ...) colMeans(X[QB2, ], ...), na.rm=TRUE))
sGPL <- as.matrix(lapply(sskwL, function(X, ...) colMeans(X[GesamtPlus, ], ...), na.rm=TRUE))
### nicht Erfolgreiche samples
nm <- nmiss(popstat=skwL[[ID]], samplestatL=sskwL, kriterien=GesamtPlus)
thismiss <- data.frame(kriterien=names(nm),missed=nm, design=Design, einrichtung=ID)
nmissDat <- rbind(nmissDat, thismiss)
###################################################
###  Bias
###################################################
BIAS <- bias(popstat=skwL[[ID]], samplestatL=sskwL, kriterien=GesamtPlus,
figs=FALSE, ask=FALSE, na.rm=TRUE)
BIAS.QB1 <- bias(popstat=QB1L[[ID]], samplestatL=sQB1L, kriterien="QB1",
figs=FALSE, ask=FALSE, na.rm=TRUE)
BIAS.QB2 <- bias(popstat=QB2L[[ID]], samplestatL=sQB2L, kriterien="QB2",
figs=FALSE, ask=FALSE, na.rm=TRUE)
BIAS.GP <- bias(popstat=GPL[[ID]], samplestatL=sGPL, kriterien="Gesamt",
figs=FALSE, ask=FALSE, na.rm=TRUE)
BIAS <- rbind(BIAS.QB1,
BIAS.QB2,
BIAS.GP)
ergArray[Design, "Bias", , , ID] <- BIAS
### Daten aufheben
## QB1
tmp <- bias(popstat=QB1L[[ID]], samplestatL=sQB1L, kriterien="QB1",
figs=FALSE, ask=FALSE, na.rm=TRUE, mkmeans=FALSE)
tmp <- cbind(tmp, design=Design, einrichtung=ID)
boxData <- rbind(boxData, tmp)
## QB1
tmp <- bias(popstat=QB2L[[ID]], samplestatL=sQB2L, kriterien="QB2",
figs=FALSE, ask=FALSE, na.rm=TRUE, mkmeans=FALSE)
tmp <- cbind(tmp, design=Design, einrichtung=ID)
boxData <- rbind(boxData, tmp)
## Gesamt
tmp <- bias(popstat=GPL[[ID]], samplestatL=sGPL, kriterien="Gesamt",
figs=FALSE, ask=FALSE, na.rm=TRUE, mkmeans=FALSE)
tmp <- cbind(tmp, design=Design, einrichtung=ID)
boxData <- rbind(boxData, tmp)
###################################################
###  RMSE
###################################################
# Achtung: Fehlende Werte
RMSE <- rmse(popstat=skwL[[ID]], samplestatL=sskwL, kriterien=GesamtPlus,
na.rm=TRUE)
RMSE.QB1 <- rmse(popstat=QB1L[[ID]], samplestatL=sQB1L, kriterien="QB1",
na.rm=TRUE)
RMSE.QB2 <- rmse(popstat=QB2L[[ID]], samplestatL=sQB2L, kriterien="QB2",
na.rm=TRUE)
RMSE.GP <- rmse(popstat=GPL[[ID]], samplestatL=sGPL, kriterien="Gesamt",
na.rm=TRUE)
RMSE <- rbind(RMSE.QB1,
RMSE.QB2,
RMSE.GP)
print(RMSE)
ergArray[Design, "RMSE", , , ID] <- RMSE
####################################################
### QB1 und QB2
###################################################
STD <- std(samplestatL=sskwL, kriterien=GesamtPlus, na.rm=TRUE)
STD.QB1 <- std(samplestatL=sQB1L, kriterien="QB1",na.rm=TRUE)
STD.QB2 <- std(samplestatL=sQB2L, kriterien="QB2", na.rm=TRUE)
STD.GP <- std(samplestatL=sGPL, kriterien="Gesamt", na.rm=TRUE)
STD <- rbind(QB1=STD.QB1,
QB2=STD.QB2,
Gesamt=STD.GP)
ergArray[Design, "STD", , , ID] <- STD
}
}
setwd("../results/")
save(boxData, file=paste("boxData_2011-12-07.rda"))
save(ergArray, file="ergArray_2011-12-07.rda")
save(nmissDat, file="nmissDat_2011-12-07.rda")
save(QB1out, QB2out, GPout, file="MDKout_2012-11-07.rda")
setwd("../prog/")
pomeans
popMeans
popMeansE
################################################################################
#
#   Code zur Stichprobenziehung ambulant
#
################################################################################
###################################################
### Funktionen laden und Datenstrukturen anlegen
###################################################
source("functions2.R")
source("sizeAmbulantSEG2F.R")
load("../daten/einrichtungen.rda")
Gesamt <- paste("T", 1:37, sep="")
QB1  <- paste("T", 1:17, sep="")
QB2 <- paste("T", 18:27, sep="")
QB3  <- paste("T", 28:37, sep="")
#einrichtKrit <- paste("T", 29:37, sep="")
# Daten noch einlesen
# Designs : SEG.2, SEG.2F, WL, QPR, HWO
# DesignL <- c("QPR", "HWO", "SEG.2F", "SEG.2", "MDK.1", "MDK.2")
DesignL <- c("SEG.2.1", "SEG.2.2", "WL", "SEG.2F")
GoodnessL <- c("Bias", "STD", "RMSE")
KriterienL <- c("Gesamt", "QB1", "QB2")
GewichtungL <- c("Einfach", "Proportional", "Vergleichbar")
einrichtungen$ID_Auftrag <- as.character(einrichtungen$ID_Auftrag)
einrichtungenL <- split(einrichtungen, f=einrichtungen$ID_Auftrag)
ID_Auftrag <- unique(einrichtungen$ID_Auftrag)
GesamtPlus <- Gesamt
ergArray <- array(NA, dim=c(length(DesignL), length(GoodnessL), length(KriterienL), length(GewichtungL), length(ID_Auftrag)),
dimnames=(list(Design=DesignL,
Goodness=GoodnessL,
Kriterien=KriterienL,
Gewichtung=GewichtungL,
ID_Auftrag=ID_Auftrag)))
boxData <- data.frame(kriterien=NA,
gewichtung=NA,
samplestat=NA,
sample=NA,
design=NA,
einrichtung=NA)
nmissDat <- data.frame(kriterien=NA, missed=NA, design=NA, einrichtung=NA)
QB1out <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
QB2out <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,,
Design=NA, Gewichtung=NA)
GPout <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
nmissDat <- data.frame(kriterien=NA, missed=NA, design=NA, einrichtung=NA)
QB1out <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
QB2out <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,,
Design=NA, Gewichtung=NA)
GPout <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
################################################################################
#
#   Code zur Stichprobenziehung ambulant
#
################################################################################
###################################################
### Funktionen laden und Datenstrukturen anlegen
###################################################
source("functions2.R")
source("sizeAmbulantSEG2F.R")
load("../daten/einrichtungen.rda")
Gesamt <- paste("T", 1:37, sep="")
QB1  <- paste("T", 1:17, sep="")
QB2 <- paste("T", 18:27, sep="")
QB3  <- paste("T", 28:37, sep="")
#einrichtKrit <- paste("T", 29:37, sep="")
# Daten noch einlesen
# Designs : SEG.2, SEG.2F, WL, QPR, HWO
# DesignL <- c("QPR", "HWO", "SEG.2F", "SEG.2", "MDK.1", "MDK.2")
DesignL <- c("SEG.2.1", "SEG.2.2", "WL", "SEG.2F")
GoodnessL <- c("Bias", "STD", "RMSE")
KriterienL <- c("Gesamt", "QB1", "QB2")
GewichtungL <- c("Einfach", "Proportional", "Vergleichbar")
einrichtungen$ID_Auftrag <- as.character(einrichtungen$ID_Auftrag)
einrichtungenL <- split(einrichtungen, f=einrichtungen$ID_Auftrag)
ID_Auftrag <- unique(einrichtungen$ID_Auftrag)
GesamtPlus <- Gesamt
ergArray <- array(NA, dim=c(length(DesignL), length(GoodnessL), length(KriterienL), length(GewichtungL), length(ID_Auftrag)),
dimnames=(list(Design=DesignL,
Goodness=GoodnessL,
Kriterien=KriterienL,
Gewichtung=GewichtungL,
ID_Auftrag=ID_Auftrag)))
boxData <- data.frame(kriterien=NA,
gewichtung=NA,
samplestat=NA,
sample=NA,
design=NA,
einrichtung=NA)
nmissDat <- data.frame(kriterien=NA, missed=NA, design=NA, einrichtung=NA)
QB1out <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
QB2out <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
GPout <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
Design <- "SEG.2"
print(Design)
if(Design %in% c("QPR", "HWO")){S <- "Pflegestufe"}
if(!Design %in% c("QPR", "HWO")){ S <- Design}
if(Design %in% c("SEG.2.1", "SEG.2.2", "SEG.2F")) S <- "SEG.2"
thisEinrichtungenL <- lapply(einrichtungenL, FUN=function(X){X[!is.na(X[, S]),]})
thisEinrichtungenL <- thisEinrichtungenL[sapply(thisEinrichtungenL, nrow)!=0]
skwL <- lapply(thisEinrichtungenL, FUN=skalenwerte,
Schichtung=S,
einrichtungen=einrichtungen,
kriterien=GesamtPlus)
### Problem: Wenn eine Einrichtung rausgeschmissen wird, dann fehlt auch die entsprechende Spalte bei den Ergebnissen.
QB1L <- lapply(skwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE)
QB2L <- lapply(skwL, function(X, ...) colMeans(X[QB2, ], ...), na.rm=TRUE)
GPL <- lapply(skwL, function(X, ...) colMeans(X[GesamtPlus, ], ...), na.rm=TRUE)
### Skalenwerte der Bereiche in der Population
tmp <- popMeansE(QB1L)
tmp2 <- cbind(tmp, Design=Design, Gewichtung=rownames(tmp))
QB1out <- rbind(QB1out, tmp2)
tmp2
print(Design)
if(Design %in% c("QPR", "HWO")){S <- "Pflegestufe"}
if(!Design %in% c("QPR", "HWO")){ S <- Design}
if(Design %in% c("SEG.2.1", "SEG.2.2", "SEG.2F")) S <- "SEG.2"
thisEinrichtungenL <- lapply(einrichtungenL, FUN=function(X){X[!is.na(X[, S]),]})
thisEinrichtungenL <- thisEinrichtungenL[sapply(thisEinrichtungenL, nrow)!=0]
skwL <- lapply(thisEinrichtungenL, FUN=skalenwerte,
Schichtung=S,
einrichtungen=einrichtungen,
kriterien=GesamtPlus)
### Problem: Wenn eine Einrichtung rausgeschmissen wird, dann fehlt auch die entsprechende Spalte bei den Ergebnissen.
QB1L <- lapply(skwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE)
QB2L <- lapply(skwL, function(X, ...) colMeans(X[QB2, ], ...), na.rm=TRUE)
GPL <- lapply(skwL, function(X, ...) colMeans(X[GesamtPlus, ], ...), na.rm=TRUE)
### Skalenwerte der Bereiche in der Population
tmp <- popMeansE(QB1L)
tmp2 <- cbind(tmp, Design=Design, Gewichtung=rownames(tmp))
source("functions2.R")
source("sizeAmbulantSEG2F.R")
skwL <- lapply(thisEinrichtungenL, FUN=skalenwerte,
Schichtung=S,
einrichtungen=einrichtungen,
kriterien=GesamtPlus)
source("functions2.R")
source("functions2.R")
skwL <- lapply(thisEinrichtungenL, FUN=skalenwerte,
Schichtung=S,
einrichtungen=einrichtungen,
kriterien=GesamtPlus)
QB1L <- lapply(skwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE)
QB2L <- lapply(skwL, function(X, ...) colMeans(X[QB2, ], ...), na.rm=TRUE)
GPL <- lapply(skwL, function(X, ...) colMeans(X[GesamtPlus, ], ...), na.rm=TRUE)
tmp <- popMeansE(QB1L)
tmp2 <- cbind(tmp, Design=Design, Gewichtung=rownames(tmp))
QB1out <- rbind(QB1out, tmp2)
class(QB1out)
names(QB1out)
QB1out <- merge(x=QB1out, y=tmp2, all.x=TRUE)
QB1out
QB1out <- merge(x=QB1out, y=tmp2, all=L)
QB1out <- merge(x=QB1out, y=tmp2, all.y=TRUE)
QB1out
QB1out <- merge(x=QB1out, y=tmp2, all=TRUE)
QB1out
QB1out <- data.frame(X0C4B=NA, X34D7=NA, X55F1=NA, X55F5=NA, X5632=NA, B227=NA, B228=NA,
Design=NA, Gewichtung=NA)
merge(x=QB1out, y=tmp2, all=TRUE)
merge(x=QB1out, y=tmp2, by=names(QB1out), all=TRUE)
merge(x=QB1out, y=tmp2, by.x=names(QB1out), all=TRUE)
merge(x=QB1out, y=tmp2, by.y=names(tmp2), all=TRUE)
popMeansE
QB1L <- lapply(skwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE)
QB1L
bereichsL <- QB1L
tmp <- bereichsL
namesE <- substring(names(tmp), 29, 32)
namesE
length(names(tmp))
names(tmp)
substr(names(tmp))
substr(names(tmp)1,2)
substr(names(tmp),1,2)
test <- "ABCDEFG"
substr(test, -1, -2)
?substr
tmp <- bereichsL
namesE <- vector()
for(i in 1:length(names(tmp))){
heimName <- names(tmp)[i]
namesE[i] <- substring(heimName, length(heimName)-4, length(heimName))
}
namesE
length(heimNam)
length(heimName)
for(i in 1:length(names(tmp))){
heimName <- names(tmp)[i]
namesE[i] <- substring(heimName, nchar(heimName)-4, nchar(heimName))
}
namesE
tmp <- popMeansE(QB1L)
tmp
source("functions2.R")
tmp
tmp <- popMeansE(QB1L)
tmp
popMeansE <- function(bereichsL){
tmp <- bereichsL
namesE <- vector()
for(i in 1:length(names(tmp))){
heimName <- names(tmp)[i]
namesE[i] <- substring(heimName, nchar(heimName)-4, nchar(heimName))
}
names(tmp) <- namesE
ge <- as.data.frame(lapply(tmp, '[', "mean"))
gp <- as.data.frame(lapply(tmp, '[', "smean"))
gv <- as.data.frame(lapply(tmp, '[', "wmean"))
gpop <- rbind(ge, gp, gv)
order <- order(names(tmp))
rownames(gpop) <- c("Einfach", "Proportional", "Vergleichbar")
return(gpop[, order])
}
tmp <- popMeansE(QB1L)
tmp
Design <- "WL"
if(Design %in% c("QPR", "HWO")){S <- "Pflegestufe"}
if(!Design %in% c("QPR", "HWO")){ S <- Design}
if(Design %in% c("SEG.2.1", "SEG.2.2", "SEG.2F")) S <- "SEG.2"
thisEinrichtungenL <- lapply(einrichtungenL, FUN=function(X){X[!is.na(X[, S]),]})
thisEinrichtungenL <- thisEinrichtungenL[sapply(thisEinrichtungenL, nrow)!=0]
skwL <- lapply(thisEinrichtungenL, FUN=skalenwerte,
Schichtung=S,
einrichtungen=einrichtungen,
kriterien=GesamtPlus)
### Problem: Wenn eine Einrichtung rausgeschmissen wird, dann fehlt auch die entsprechende Spalte bei den Ergebnissen.
QB1L <- lapply(skwL, function(X, ...) colMeans(X[QB1, ], ...), na.rm=TRUE)
QB2L <- lapply(skwL, function(X, ...) colMeans(X[QB2, ], ...), na.rm=TRUE)
GPL <- lapply(skwL, function(X, ...) colMeans(X[GesamtPlus, ], ...), na.rm=TRUE)
### Skalenwerte der Bereiche in der Population
tmp <- popMeansE(QB1L)
tmp
names(einrichtungenL)
tmp <- bereichsL
namesE <- vector()
for(i in 1:length(names(tmp))){
heimName <- names(tmp)[i]
namesE[i] <- substring(heimName, nchar(heimName)-4, nchar(heimName))
}
namesE
names(tmp) <- namesE
tmp
ge <- as.data.frame(lapply(tmp, '[', "mean"))
gp <- as.data.frame(lapply(tmp, '[', "smean"))
gv <- as.data.frame(lapply(tmp, '[', "wmean"))
gpop <- rbind(ge, gp, gv)
order <- order(names(tmp))
rownames(gpop) <- c("Einfach", "Proportional", "Vergleichbar")
names(E)
namesE
rownames(gpop) <- c("Einfach", "Proportional", "Vergleichbar")
gpop[, order]
nmissDat <- data.frame(kriterien=NA, missed=NA, design=NA, einrichtung=NA)
QB1out <- data.frame(X034D7=NA,   X655F1=NA,   X655F5=NA,   X65632=NA,    BB227=NA,  BB228=NA,    C0C4B=NA,
Design=NA, Gewichtung=NA)
QB2out <- data.frame(X034D7=NA,   X655F1=NA,   X655F5=NA,   X65632=NA,    BB227=NA,  BB228=NA,    C0C4B=NA,
Design=NA, Gewichtung=NA)
GPout <- data.frame(X034D7=NA,   X655F1=NA,   X655F5=NA,   X65632=NA,    BB227=NA,  BB228=NA,    C0C4B=NA,
Design=NA, Gewichtung=NA)
source('Y:/_PROJEKTE_/MDK_in_Bayern/Dezember2011/prog/sampleAmbulant.r')
setwd("../results/")
save(boxData, file=paste("boxData_2011-12-07.rda"))
save(ergArray, file="ergArray_2011-12-07.rda")
save(nmissDat, file="nmissDat_2011-12-07.rda")
save(QB1out, QB2out, GPout, file="MDKout_2012-11-07.rda")
setwd("../prog/")
setwd("~/Dropbox/svgmaps/pkg/demo")
source("../R/osmarDataTransform.R")
source("../R/mapDataToGraphic.R")
load("../data/home.rda")
system.time(m <- svgmap(home, polygons=list(alpha="version", fill="building")))
library(osmar)
library(ggplot2)
system.time(m <- svgmap(home, polygons=list(alpha="version", fill="building")))
library(gridSVG)
install.packages("gridSVG")
library(help=grid)
?ggplotGrob
