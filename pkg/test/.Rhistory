dat_with_coords$id <- NULL
dat_with_coords$point_id <- seq_len(nrow(dat_with_coords))
dat_with_coords_sub<- melt(dat_with_coords, id.vars=c("element_id", "lon", "lat", "point_id"))
dat_with_coords_sub <- subset(dat_with_coords_sub, subset=(variable==vars))
dat_with_coords_sub
}
spatialPolygonsDataFrame_long(polyDat, "z")
coo
names(coo)
spatialPolygonsDataFrame_long <- function(sp_polygons_df, vars){
# extract the data
dat <- sp_polygons_df@data
dat$id <- rownames(dat)
# extract the coordinates; therefore split
coo <- ldply(sp_polygons_df@polygons, .fun=function(X){
## id of the Lines object
id <- X@ID
## There can be more than one Line in Lines
coords <- data.frame()
## Extracts all the Line elements from one Lines element
for(i in seq_len(length(X@Polygons))) {
coords_temp <- data.frame(X@Polygons[[i]]@coords, row.names=NULL)
element_id <- paste(id, i, sep=".")
coords_temp$element_id <-  element_id
coords <- rbind(coords, coords_temp)
}
cbind(coords, id)
})
# first column lon and second lat
coo <- rename(coo, c(x="lon", y="lat"))
dat_with_coords <- merge(dat, coo, by="id")
# Id is not needed any more, so drop it
dat_with_coords$id <- NULL
dat_with_coords$point_id <- seq_len(nrow(dat_with_coords))
dat_with_coords_sub<- melt(dat_with_coords, id.vars=c("element_id", "lon", "lat", "point_id"))
dat_with_coords_sub <- subset(dat_with_coords_sub, subset=(variable==vars))
dat_with_coords_sub
}
spatialPolygonsDataFrame_long(polyDat, "z")
test <- spatialPolygonsDataFrame_long(polyDat, "z")
ggplot(test) + geom_polygon(aes(x=lon, y=lat))
ggplot(test) + geom_polygon(aes(x=lon, y=lat, group=element_id))
ggplot(test) + geom_polygon(aes(x=lon, y=lat, group=element_id), fill=FALSE)
test
head(test)
ggplot(test) + geom_polygon(aes(x=lon, y=lat, group=element_id, fill=value))
ggplot(test) + geom_polygon(aes(x=lon, y=lat, group=element_id, fill=element_id))
ggplot(test) + geom_path(aes(x=lon, y=lat, group=element_id, fill=element_id))
spatialLinesDataFrame_long <- function(sp_lines_df, vars=""){
# extract the data
dat <- sp_lines_df@data
dat$id <- rownames(dat)
# extract the coordinates; therefore split
coo <- ldply(sp_lines_df@lines, .fun=function(X){
## id of the Lines object
id <- X@ID
## There can be more than one Line in Lines
coords <- data.frame()
## Extracts all the Line elements from one Lines element
for(i in seq_len(length(X@Lines))) {
coords_temp <- data.frame(X@Lines[[i]]@coords)
element_id <- paste(id, i, sep=".")
coords_temp$element_id <-  element_id
coords <- rbind(coords, coords_temp)
}
cbind(coords, id)
})
# first column lon and second lat
coo <- rename(coo, c(X1="lon", X2="lat"))
dat_with_coords <- merge(dat, coo, by="id")
# Id is not needed any more, so drop it
dat_with_coords$id <- NULL
dat_with_coords$point_id <- seq_len(nrow(dat_with_coords))
dat_with_coords_sub<- melt(dat_with_coords, id.vars=c("element_id", "lon", "lat", "point_id"))
dat_with_coords_sub <- subset(dat_with_coords_sub, subset=(variable==vars))
dat_with_coords_sub$plot_type <- "line"
dat_with_coords_sub
}
spatialPolygonsDataFrame_long <- function(sp_polygons_df, vars){
# extract the data
dat <- sp_polygons_df@data
dat$id <- rownames(dat)
# extract the coordinates; therefore split
coo <- ldply(sp_polygons_df@polygons, .fun=function(X){
## id of the Lines object
id <- X@ID
## There can be more than one Line in Lines
coords <- data.frame()
## Extracts all the Line elements from one Lines element
for(i in seq_len(length(X@Polygons))) {
coords_temp <- data.frame(X@Polygons[[i]]@coords, row.names=NULL)
element_id <- paste(id, i, sep=".")
coords_temp$element_id <-  element_id
coords <- rbind(coords, coords_temp)
}
cbind(coords, id)
})
# first column lon and second lat
coo <- rename(coo, c(x="lon", y="lat"))
dat_with_coords <- merge(dat, coo, by="id")
# Id is not needed any more, so drop it
dat_with_coords$id <- NULL
dat_with_coords$point_id <- seq_len(nrow(dat_with_coords))
dat_with_coords_sub<- melt(dat_with_coords, id.vars=c("element_id", "lon", "lat", "point_id"))
dat_with_coords_sub <- subset(dat_with_coords_sub, subset=(variable==vars))
dat_with_coords_sub$plot_type <- "polygon"
dat_with_coords_sub
}
test <- spatialPolygonsDataFrame_long(polyDat, "z")
head(test)
wa <- washington.tract
data(washington.tract)
library(UScensus2000tract)
install.packages("UScensus2000tract")
install.packages("UScensus2000")
install.packages("mboost")
install.packages("UScensus2000")
install.packages("UScensus2000tract")
getwd()
load("../../../Downloads/DEU_adm3.RData")
gadm
con <- url("http://www.filefactory.com/file/c2a3543/n/DEU_adm3.RData")
print(load(con))
gadm_long <- spatialPolygonsDataFrame_long(gadm)
gadm
gadm_long <- spatialPolygonsDataFrame_long(gadm)
sp_polygons_df <- gadm_long
sp_polygons_df <- gadm
sp_polygons
dat <- sp_polygons_df@data
dat
dat$id <- rownames(dat)
coo <- ldply(sp_polygons_df@polygons, .fun=function(X){
## id of the Lines object
id <- X@ID
## There can be more than one Line in Lines
coords <- data.frame()
## Extracts all the Line elements from one Lines element
for(i in seq_len(length(X@Polygons))) {
coords_temp <- data.frame(X@Polygons[[i]]@coords, row.names=NULL)
element_id <- paste(id, i, sep=".")
coords_temp$element_id <-  element_id
coords <- rbind(coords, coords_temp)
}
cbind(coords, id)
})
head(coo)
spatialPolygonsDataFrame_long <- function(sp_polygons_df, vars){
# extract the data
dat <- sp_polygons_df@data
dat$id <- rownames(dat)
# extract the coordinates; therefore split
coo <- ldply(sp_polygons_df@polygons, .fun=function(X){
## id of the Lines object
id <- X@ID
## There can be more than one Line in Lines
coords <- data.frame()
## Extracts all the Line elements from one Lines element
for(i in seq_len(length(X@Polygons))) {
coords_temp <- data.frame(X@Polygons[[i]]@coords, row.names=NULL)
element_id <- paste(id, i, sep=".")
coords_temp$element_id <-  element_id
coords <- rbind(coords, coords_temp)
}
cbind(coords, id)
})
# first column lon and second lat
# sure????
names(coo)[1:2] <- c("lon", "lat")
# coo <- rename(coo, c(x="lon", y="lat"))
dat_with_coords <- merge(dat, coo, by="id")
# Id is not needed any more, so drop it
dat_with_coords$id <- NULL
dat_with_coords$point_id <- seq_len(nrow(dat_with_coords))
dat_with_coords_sub<- melt(dat_with_coords, id.vars=c("element_id", "lon", "lat", "point_id"))
dat_with_coords_sub <- subset(dat_with_coords_sub, subset=(variable==vars))
dat_with_coords_sub$plot_type <- "polygon"
dat_with_coords_sub
}
gadm_long <- spatialPolygonsDataFrame_long(gadm)
head(dat)
spatialPolygonsDataFrame_long <- function(sp_polygons_df, vars=""){
# extract the data
dat <- sp_polygons_df@data
dat$id <- rownames(dat)
# extract the coordinates; therefore split
coo <- ldply(sp_polygons_df@polygons, .fun=function(X){
## id of the Lines object
id <- X@ID
## There can be more than one Line in Lines
coords <- data.frame()
## Extracts all the Line elements from one Lines element
for(i in seq_len(length(X@Polygons))) {
coords_temp <- data.frame(X@Polygons[[i]]@coords, row.names=NULL)
element_id <- paste(id, i, sep=".")
coords_temp$element_id <-  element_id
coords <- rbind(coords, coords_temp)
}
cbind(coords, id)
})
# first column lon and second lat
# sure????
names(coo)[1:2] <- c("lon", "lat")
# coo <- rename(coo, c(x="lon", y="lat"))
dat_with_coords <- merge(dat, coo, by="id")
# Id is not needed any more, so drop it
dat_with_coords$id <- NULL
dat_with_coords$point_id <- seq_len(nrow(dat_with_coords))
dat_with_coords_sub<- melt(dat_with_coords, id.vars=c("element_id", "lon", "lat", "point_id"))
dat_with_coords_sub <- subset(dat_with_coords_sub, subset=(variable==vars))
dat_with_coords_sub$plot_type <- "polygon"
dat_with_coords_sub
}
gadm_long <- spatialPolygonsDataFrame_long(gadm)
traceback()
spatialPolygonsDataFrame_long <- function(sp_polygons_df, vars=""){
# extract the data
dat <- sp_polygons_df@data
dat$id <- rownames(dat)
# extract the coordinates; therefore split
coo <- ldply(sp_polygons_df@polygons, .fun=function(X){
## id of the Lines object
id <- X@ID
## There can be more than one Line in Lines
coords <- data.frame()
## Extracts all the Line elements from one Lines element
for(i in seq_len(length(X@Polygons))) {
coords_temp <- data.frame(X@Polygons[[i]]@coords, row.names=NULL)
element_id <- paste(id, i, sep=".")
coords_temp$element_id <-  element_id
coords <- rbind(coords, coords_temp)
}
cbind(coords, id)
})
# first column lon and second lat
# sure????
names(coo)[1:2] <- c("lon", "lat")
# coo <- rename(coo, c(x="lon", y="lat"))
dat_with_coords <- merge(dat, coo, by="id")
# Id is not needed any more, so drop it
dat_with_coords$id <- NULL
dat_with_coords$point_id <- seq_len(nrow(dat_with_coords))
dat_with_coords_sub$plot_type <- "polygon"
dat_with_coords_sub<- melt(dat_with_coords, id.vars=c("element_id", "lon", "lat", "point_id"))
dat_with_coords_sub <- subset(dat_with_coords_sub, subset=(variable==vars))
# take care for empty datasets
dat_with_coords_sub
}
names(dat)
gadm_long <- spatialPolygonsDataFrame_long(gadm, vars="NAME_3")
# maybe change the order of subsetting and melting also in spatialLines
spatialPolygonsDataFrame_long <- function(sp_polygons_df, vars=""){
# extract the data
dat <- sp_polygons_df@data
dat$id <- rownames(dat)
# extract the coordinates; therefore split
coo <- ldply(sp_polygons_df@polygons, .fun=function(X){
## id of the Lines object
id <- X@ID
## There can be more than one Line in Lines
coords <- data.frame()
## Extracts all the Line elements from one Lines element
for(i in seq_len(length(X@Polygons))) {
coords_temp <- data.frame(X@Polygons[[i]]@coords, row.names=NULL)
element_id <- paste(id, i, sep=".")
coords_temp$element_id <-  element_id
coords <- rbind(coords, coords_temp)
}
cbind(coords, id)
})
# first column lon and second lat
# sure????
names(coo)[1:2] <- c("lon", "lat")
# coo <- rename(coo, c(x="lon", y="lat"))
dat_with_coords <- merge(dat, coo, by="id")
# Id is not needed any more, so drop it
dat_with_coords$id <- NULL
dat_with_coords$point_id <- seq_len(nrow(dat_with_coords))
dat_with_coords$plot_type <- "polygon"
dat_with_coords_sub<- melt(dat_with_coords, id.vars=c("element_id", "lon", "lat", "point_id"))
dat_with_coords_sub <- subset(dat_with_coords_sub, subset=(variable==vars))
# take care for empty datasets
dat_with_coords_sub
}
gadm_long <- spatialPolygonsDataFrame_long(gadm, vars="NAME_3")
head(gadm_long)
head(test3)
source("../R/osmarDataTransform.R")
source("../R/plotMap.R")
load("../data/home.rda")
# for coords_map()
library(mapproj)
# for tiles
library(ggmap)
# dim(osmar_coords_relations(home))
home <- heidi
dim(osmar_coords_nodes(home))
head(osmar_coords_ways(home))
system.time({
test <- osmar_long(home, vars=c("shop"), element="nodes")
test2 <- osmar_long(home, vars=c("highway", "building"), element="ways")
# does not work
# test3 <- osmar_long(home, vars="version", element="relations")
})
head(test)
#########  test the order
test_id <- 30171930
plot(lat~lon, test2[test2$element_id == 30171930, ])
test2[test2$element_id == 30171930, ]
# in dataset
test_way <- osmar:::subset.osmar(home, way_ids=30171930)
test_way$ways$refs
# after matching nodes to way:
coo <- osmar_coords_ways(home)
coo_sub <- coo[coo$element_id== test_id,]
coo_sub
############# Plots
library(ggplot2)
## change dataset
# test3 <- subset(test2, subset=(k == "highway"))
test3 <- test2
test3 <- cast(test3, element_id + node_id + lat + lon + plot_type + type + plot_order ~ variable, value="value")
test3 <- test3[order(test3$element_id, test3$plot_order),]
test <- cast(test, element_id + node_id + lat + lon + plot_type + type + plot_order ~ variable, value="value")
head(gadm_long)
ggplot(gadm_long) + geom_path(aes(x=lon, y=lat, group=element_id, fill=element_id))
ggplot(gadm_long) + geom_path(aes(x=lon, y=lat, group=element_id, fill=NAME_3))
ggplot(gadm_long) + geom_path(aes(x=lon, y=lat, group=element_id, fill=value))
ggplot(gadm_long) + geom_path(aes(x=lon, y=lat, group=element_id, fill=value))
ggplot(gadm_long) + geom_polygon(aes(x=lon, y=lat, group=element_id, fill=value))
ggplot(gadm_long) + geom_polygon(aes(x=lon, y=lat, group=element_id, fill=value)) + coord_map()
nodes <- osmar_merge_attrs_tags(home$nodes)
source("../R/osmarDataTransform.R")
load("../data/home.rda")
nodes <- osmar_merge_attrs_tags(home$nodes)
nodes <- osmar_merge_attrs_and_tags(home$nodes)
nodes_yes <- osmar_merge_attrs_and_tags(home$nodes, vars="version")
traceback()
osmar_ob_el <- home$nodes
osmar_obj_attrs <- osmar_obj_el$attrs
osmar_obj_el <- home$nodes
osmar_obj_attrs <- osmar_obj_el$attrs
attrs_tagform <- osmar_attrs_to_tags(osmar_obj_attrs, vars)
vars <- "verson"
vars <- "version"
attrs_tagform <- osmar_attrs_to_tags(osmar_obj_attrs, vars)
attrs_tagform
osmar_obj_tags <- osmar_obj_el$tags
osmar_obj_tags <- rename(osmar_obj_tags, c(k="variable", v="values"))
rbind(attrs_tagform, osmar_obj_tags)
names(osmar_obj_tags)
names(attrs_tagform)
?melt.data.frame
head(melt(tips))
nodes_yes <- osmar_merge_attrs_and_tags(home$nodes, vars="version")
osmar_merge_attrs_and_tags <- function(osmar_obj_el, vars){
# attrs
osmar_obj_attrs <- osmar_obj_el$attrs
attrs_tagform <- osmar_attrs_to_tags(osmar_obj_attrs, vars)
# tags
osmar_obj_tags <- osmar_obj_el$tags
osmar_obj_tags <- rename(osmar_obj_tags, c(k="variable", v="value"))
# bind together
rbind(attrs_tagform, osmar_obj_tags)
}
nodes_yes <- osmar_merge_attrs_and_tags(home$nodes, vars="version")
nodes_yes
nodes_no <- osmar_merge_attrs_and_tags(home$nodes, vars="xxx")
nodes_no
nodes_yes <- osmar_merge_attrs_and_tags(home$nodes, vars="uid")
nodes_yes
dim(nodes_yes)
dim(nodes_no)
nodes_no <- osmar_merge_attrs_and_tags(home$nodes, vars="xxx")
dim(nodes_no)
relations_yes <- osmar_merge_attrs_and_tags(home$lines, vars="timestamp")
relations_no <- osmar_merge_attrs_and_tags(home$lines, vars="katzenklo")
names(nodes_no)
expect_that(df_has_names(namez))
osmar_merge_coords_attrs <- function(coords, attrs, vars,  plot_type){
coords$plot_type <- plot_type
attrs_sub <- subset(attrs, subset=(variable %in% vars), drop=TRUE)
all <- merge(coords, attrs_sub, by.x="element_id", by.y="id", all.x=TRUE, sort=FALSE)
all
}
setwd("~/Dropbox/svgmaps/test")
library(testthat)
test_dir()
test_dir("./")
test_dir("./")
ways_yes <- osmar_merge_attrs_and_tags(home$lines, vars="version")
head(ways_yes)
head(ways_yes)
ways_yes <- osmar_merge_attrs_and_tags(home$lines, vars="version")
test_dir("./")
test_dir("./")
test_dir("./")
relations_no <- osmar_merge_attrs_and_tags(home$relations, vars="katzenklo")
head(relations_no)
head(relations_yes)
relations_yes <- osmar_merge_attrs_and_tags(home$relations, vars="timestam")
relations_yes
test_dir("./")
relations_no <- osmar_merge_attrs_and_tags(home$relations, vars="katzenklo")
class(relations_no)
dim(relations_no)
test_dir("./")
test_dir("./")
relations_yes <- osmar_merge_attrs_and_tags(home$relations, vars="timestamp")
traceback()
omar_obj_el <- home$nodes
vars <- "timestamp"
osmar_obj_attrs <- osmar_obj_el$attrs
attrs_tagform <- osmar_attrs_to_tags(osmar_obj_attrs, vars)
# tags
osmar_obj_tags <- osmar_obj_el$tags
osmar_obj_tags <- rename(osmar_obj_tags, c(k="variable", v="value"))
osmar_obj_tags
head(osmar_obj_tags)
head(attrs_tagform)
rbind(attrs_tagform, osmar_obj_tags)
class(attrs_tagform)
class(attrs_tagform$value)
class(attrs_tagform$value) <- "character"
rbind(attrs_tagform, osmar_obj_tags)
test_that("osmar_merge_attrs_and_tags works",{
# yes: variable exists, no: doesn't exist
nodes_yes <- osmar_merge_attrs_and_tags(home$nodes, vars="uid")
nodes_no <- osmar_merge_attrs_and_tags(home$nodes, vars="xxx")
ways_yes <- osmar_merge_attrs_and_tags(home$ways, vars="version")
ways_no <- osmar_merge_attrs_and_tags(home$ways, vars="")
relations_yes <- osmar_merge_attrs_and_tags(home$relations, vars="timestamp")
relations_no <- osmar_merge_attrs_and_tags(home$relations, vars="katzenklo")
expect_that(nodes_yes, is_not_empty())
expect_that(nodes_no,is_not_empty())
expect_that(ways_yes, is_not_empty())
expect_that(ways_no, is_not_empty())
expect_that(relations_yes, is_not_empty())
expect_that(relations_no, is_not_empty())
namez <- c("id", "variable", "value")
expect_that(nodes_yes, df_has_names(namez))
expect_that(nodes_no, df_has_names(namez))
expect_that(ways_yes, df_has_names(namez))
expect_that(ways_no, df_has_names(namez))
expect_that(relations_yes, df_has_names(namez))
expect_that(relations_no, df_has_names(namez))
})
test_dir("./")
?proto
?fortify
?fortify.sp
?fortify.shp
fortify
methods(fortify)
?fortifySpatialLinesDataFram
?fortifySpatialLinesDataFrame
?fortify.SpatialLinesDataFrame
con <- url("http://www.filefactory.com/file/c2a3543/n/DEU_adm3.RData")
print(load(con))
close(con)
fortify(gadm)
install.packages("gpclib")
fortify(gadm)
fortify.SpatialPolygonsDataFrame
polygons(gadm)
fortify.SpatialPolygonsDataFrame
addNA
fortify(gadm)
library('maptools')
gpclibPermit()
fortify(gadm)
head(fortify(gadm))
methods(fortify)
l1 = cbind(c(1,2,3),c(3,2,2))
l1a = cbind(l1[,1]+.05,l1[,2]+.05)
l2 = cbind(c(1,2,3),c(1,1.5,1))
Sl1 = Line(l1)
Sl1a = Line(l1a)
Sl2 = Line(l2)
S1 = Lines(list(Sl1, Sl1a), ID="a")
S2 = Lines(list(Sl2), ID="b")
S3 = Lines(list(Line(cbind(c(3,4,5), c(2,3,9)))), ID="c")
Sl = SpatialLines(list(S2,S1, S3))
summary(Sl)
df = data.frame(z = c(1,2,3), row.names=sapply(slot(Sl, "lines"), function(x) slot(x, "ID")))
Sldf = SpatialLinesDataFrame(Sl, data = df)
summary(Sldf)
# coordinates
coordinates(Sldf)
d <- spatialLinesDataFrame_long(Sldf, "z")
(d)
d2 <- fortify(Sldf)
d2
Sldf
d2 <- fortify(Sldf)
d2
?gpclibPermit
gadm_long <- spatialPolygonsDataFrame_long(gadm, vars="NAME_3")
system.time(g2 <- fortify(gadm))
system.time(gadm_long <- spatialPolygonsDataFrame_long(gadm, vars="NAME_3"))
data(meuse)
meuse2 <- meuse
coordinates(meuse2) <- c("x","y")
class(meuse2)
fortify(meuse2)
??readShapePoly
?readShapePoly
library(help=maptools)
?ggstructure
ggstructure
ggpcp
?ggpcp
